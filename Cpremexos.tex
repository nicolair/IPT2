\begin{enumerate}
  \item Une bonne pratique pour coder efficacement est d'utiliser une \emph{phrase invariante} vraie à l'initialisation et qui le reste aux étapes clés de l'exécution. Par exemple dans le cas de la factorielle, considérons 
\begin{center}
  \og \texttt{f} désigne la factorielle de \texttt{n} \fg
\end{center}
Il s'agit alors
\begin{itemize}
  \item d'initialiser les noms \texttt{f} et \texttt{n} pour qu'elle soit vraie au début
  \item de former un bloc d'instructions tel que, si la phrase est vraie avant l'exécution du bloc elle reste vraie après.
\end{itemize}
\lstinputlisting[firstline=1, lastline=12]{Cpremexos.py}

\item On se donne un entier naturel désigné par \texttt{n}. Décomposons le problème posé par l'énoncé en deux parties
\begin{itemize}
  \item trouver le plus petit nombre $\geq 2$ et divisant \texttt{n}
  \item afficher \texttt{premier} ou \texttt{composé} suivant le nombre trouvé. 
\end{itemize}
\lstinputlisting[firstline=14, lastline=21]{Cpremexos.py}
Les diviseurs ne vont jamais seuls : $p$ divise $n$ si et seulement si il existe $q$ tel que $pq=n$. Les deux sont des diviseurs et l'un d'entre eux est plus petit que la racine carrée de $n$. 
On peut raccourcir la boucle en remplaçant la condition par \texttt{n \% p != 0 and p*p <= n }\newline
Pour calculer le nombre de diviseurs, on incrémente un compteur. On peut l'incrémenter de 2 en faisant attention aux carrés
\lstinputlisting[firstline=23, lastline=32]{Cpremexos.py}

\item Considérons la phrase
\begin{center}
  \og \texttt{2554} =\texttt{i} fois \texttt{p} plus \texttt{n} \fg
\end{center}
Elle s'évalue à VRAI après l'initialisation car \texttt{n} désigne $2554$ et \texttt{i} désigne $0$. De plus \texttt{p} désigne 39 et ceci ne changera pas car \texttt{p} ne figure jamais à gauche d'une assignation.\newline
Après l'exécution d'un bloc, \texttt{n} est décrémenté de \texttt{p} et \texttt{i} est incrémenté de $1$. La phrase s'évalue donc toujours à VRAI.\newline
Après la sortie de la boucle, \texttt{n} désigne un entier $\leq 39$ et la phrase s'évalue toujours à VRAI.
\begin{itemize}
  \item Si \texttt{n} désigne un entier $<$ \texttt{p} , le code affiche le reste et le quotient (dans cet ordre) de la division de $2554$ par \texttt{p}. (c'est le cas pour 2554 et 39)
  \item Si \texttt{n} désigne le même entier que \texttt{p}, le quotient est \texttt{i}-1. 
\end{itemize}
Ce code sera amélioré en remplaçant dans le test de la boucle \texttt{while} l'inégalité stricte par une inégalité large.

\item
\begin{enumerate}
  \item L'affichage du tableau vide se fait avec le code suivant
\lstinputlisting[firstline=78, lastline=123]{Cpremexos.py}

  \item Code pour l'affichage d'un cercle. Noter qu'il faut prendre une valeur assez grande pour l'erreur \texttt{e} et qu'il faut afficher deux caractères pour corriger le fait que la hauteur d'une ligne est plus grande que la longueur d'un caractère.
\lstinputlisting[firstline=126, lastline=141]{Cpremexos.py}
\end{enumerate}


\item Suite de Syracuse
\begin{enumerate}
  \item Pour calculer et afficher les 20 premiers termes
\lstinputlisting[firstline=144, lastline=152]{Cpremexos.py}
  
  \item On change le test de la boucle et on en sort l'affichage. On garde la condition \texttt{n < 20} dans le test par précaution.
\lstinputlisting[firstline=156, lastline=164]{Cpremexos.py}
  \item On convient d'appeler \emph{temps de vol} le $i(x)$ pour une valeur initiale $x$. Le code suivant affiche le plus long temps de vol et sa condition initiale pour des conditions initiales entre 1 et \texttt{X} et un temps de vol limité à \texttt{Niter}. 
\lstinputlisting[firstline=167, lastline=185]{Cpremexos.py}
\end{enumerate}


\item L'implémentation Python du pseudo-code est
\lstinputlisting[firstline=35, lastline=44]{Cpremexos.py}
Ce code calcule essentiellement la décomposition binaire de l'entier donné sauf qu'il écrit des \texttt{P} et des \texttt{I} au lieu de \texttt{0} et de \texttt{1}. De plus, il les écrit de gauche à droite et non de gauche à droite comme on doit le faire en numération. Pour la décomposition binaire, on peut utiliser
\lstinputlisting[firstline=46, lastline=57]{Cpremexos.py}
Plus généralement, on peut éviter les tests, par exemple en base 3
\lstinputlisting[firstline=60, lastline=68]{Cpremexos.py}
La fonction Python \texttt{int} permet de vérifier le calcul. C'est une fonction dite de \emph{transtypage} (cast en anglais) de \texttt{str} vers \texttt{int} c'est à dire qu'elle renvoie un entier lié à la chaîne de caractères fournie en paramètre. 

\end{enumerate}

